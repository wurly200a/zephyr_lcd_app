#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/drivers/display.h>
#include <zephyr/logging/log.h>
#include <zephyr/sys/byteorder.h>
#include <string.h>
#include <stdint.h>

LOG_MODULE_REGISTER(app, LOG_LEVEL_INF);

/* BL=IO32（HIGHで点灯。基板が逆なら GPIO_OUTPUT_INACTIVE に） */
#define BLK_PORT DT_NODELABEL(gpio0)
#define BLK_PIN  32

/* 5x7 ASCII フォント（32..127）。5列×7行、右1列スペースで6px幅扱い */
static const uint8_t font5x7[96][5] = {
    {0,0,0,0,0},{0,0,0x5F,0,0},{0,7,0,7,0},{0x14,0x7F,0x14,0x7F,0x14},
    {0x24,0x2A,0x7F,0x2A,0x12},{0x23,0x13,0x08,0x64,0x62},{0x36,0x49,0x55,0x22,0x50},{0,5,3,0,0},
    {0,0x1C,0x22,0x41,0},{0,0x41,0x22,0x1C,0},{0x14,0x08,0x3E,0x08,0x14},{0x08,0x08,0x3E,0x08,0x08},
    {0,0x50,0x30,0,0},{0x08,0x08,0x08,0x08,0x08},{0,0x60,0x60,0,0},{0x20,0x10,0x08,0x04,0x02},
    {0x3E,0x51,0x49,0x45,0x3E},{0,0x42,0x7F,0x40,0},{0x42,0x61,0x51,0x49,0x46},{0x21,0x41,0x45,0x4B,0x31},
    {0x18,0x14,0x12,0x7F,0x10},{0x27,0x45,0x45,0x45,0x39},{0x3C,0x4A,0x49,0x49,0x30},{0x01,0x71,0x09,0x05,0x03},
    {0x36,0x49,0x49,0x49,0x36},{0x06,0x49,0x49,0x29,0x1E},{0,0x36,0x36,0,0},{0,0x56,0x36,0,0},
    {0x08,0x14,0x22,0x41,0},{0x14,0x14,0x14,0x14,0x14},{0,0x41,0x22,0x14,0x08},{0x02,0x01,0x51,0x09,0x06},
    {0x32,0x49,0x79,0x41,0x3E},{0x7E,0x11,0x11,0x11,0x7E},{0x7F,0x49,0x49,0x49,0x36},{0x3E,0x41,0x41,0x41,0x22},
    {0x7F,0x41,0x41,0x22,0x1C},{0x7F,0x49,0x49,0x49,0x41},{0x7F,0x09,0x09,0x09,0x01},{0x3E,0x41,0x49,0x49,0x7A},
    {0x7F,0x08,0x08,0x08,0x7F},{0,0x41,0x7F,0x41,0},{0x20,0x40,0x41,0x3F,0x01},{0x7F,0x08,0x14,0x22,0x41},
    {0x7F,0x40,0x40,0x40,0x40},{0x7F,0x02,0x0C,0x02,0x7F},{0x7F,0x04,0x08,0x10,0x7F},{0x3E,0x41,0x41,0x41,0x3E},
    {0x7F,0x09,0x09,0x09,0x06},{0x3E,0x41,0x51,0x21,0x5E},{0x7F,0x09,0x19,0x29,0x46},{0x46,0x49,0x49,0x49,0x31},
    {0x01,0x01,0x7F,0x01,0x01},{0x3F,0x40,0x40,0x40,0x3F},{0x1F,0x20,0x40,0x20,0x1F},{0x7F,0x20,0x18,0x20,0x7F},
    {0x63,0x14,0x08,0x14,0x63},{0x07,0x08,0x70,0x08,0x07},{0x61,0x51,0x49,0x45,0x43},{0,0x7F,0x41,0x41,0},
    {0x02,0x04,0x08,0x10,0x20},{0,0x41,0x41,0x7F,0},{0x04,0x02,0x01,0x02,0x04},{0x40,0x40,0x40,0x40,0x40},
    {0,0x01,0x02,0x04,0},{0x20,0x54,0x54,0x54,0x78},{0x7F,0x48,0x44,0x44,0x38},{0x38,0x44,0x44,0x44,0x20},
    {0x38,0x44,0x44,0x48,0x7F},{0x38,0x54,0x54,0x54,0x18},{0x08,0x7E,0x09,0x01,0x02},{0x0C,0x52,0x52,0x52,0x3E},
    {0x7F,0x08,0x04,0x04,0x78},{0,0x44,0x7D,0x40,0},{0x20,0x40,0x44,0x3D,0},{0x7F,0x10,0x28,0x44,0},
    {0,0x41,0x7F,0x40,0},{0x7C,0x04,0x18,0x04,0x78},{0x7C,0x08,0x04,0x04,0x78},{0x38,0x44,0x44,0x44,0x38},
    {0x7C,0x14,0x14,0x14,0x08},{0x08,0x14,0x14,0x18,0x7C},{0x7C,0x08,0x04,0x04,0x08},{0x48,0x54,0x54,0x54,0x20},
    {0x04,0x3F,0x44,0x40,0x20},{0x3C,0x40,0x40,0x20,0x7C},{0x1C,0x20,0x40,0x20,0x1C},{0x3C,0x40,0x30,0x40,0x3C},
    {0x44,0x28,0x10,0x28,0x44},{0x0C,0x50,0x50,0x50,0x3C},{0x44,0x64,0x54,0x4C,0x44},{0,0x08,0x36,0x41,0},
    {0,0,0x7F,0,0},{0,0x41,0x36,0x08,0},{0x08,0x04,0x08,0x10,0x08},{0,0,0,0,0}
};

#define FONT_W 5
#define FONT_H 7
#define CHAR_SP 1
#define SCALE 2
#define CW ((FONT_W + CHAR_SP) * SCALE)
#define CH (FONT_H * SCALE)

static uint16_t glyphbuf[CW * CH];
#define TILE_H 24
static uint16_t linebuf[320 * TILE_H];

static inline uint16_t rgb565_be(uint8_t r, uint8_t g, uint8_t b) {
    uint16_t v = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
    return sys_cpu_to_be16(v); /* ILI9341 はMSB先送 */
}

static void fill_screen(const struct device *disp, uint16_t w, uint16_t h, uint16_t color_be) {
    struct display_buffer_descriptor desc = { .width = w, .height = 0, .pitch = w, .buf_size = 0 };
    for (uint16_t yy = 0; yy < h; yy += TILE_H) {
        uint16_t hh = (h - yy) < TILE_H ? (h - yy) : TILE_H;
        size_t px = (size_t)w * hh;
        for (size_t i = 0; i < px; i++) linebuf[i] = color_be;
        desc.height = hh;
        desc.buf_size = (uint32_t)w * hh * 2U;
        (void)display_write(disp, 0, yy, &desc, linebuf);
    }
}

static void draw_char(const struct device *disp, uint16_t x, uint16_t y,
                      char c, uint16_t fg_be, uint16_t bg_be) {
    if ((uint8_t)c < 32 || (uint8_t)c > 127) c = '?';
    const uint8_t *cols = font5x7[(uint8_t)c - 32];

    for (size_t i = 0; i < ARRAY_SIZE(glyphbuf); i++) glyphbuf[i] = bg_be;

    for (int col = 0; col < FONT_W; col++) {
        uint8_t bits = cols[col];
        for (int row = 0; row < FONT_H; row++) {
            if (bits & (1u << row)) {
                for (int dy = 0; dy < SCALE; dy++)
                for (int dx = 0; dx < SCALE; dx++) {
                    int px = (col * SCALE + dx);
                    int py = (row * SCALE + dy);
                    glyphbuf[py * CW + px] = fg_be;
                }
            }
        }
    }

    struct display_buffer_descriptor desc = { .width = CW, .height = CH, .pitch = CW, .buf_size = CW * CH * 2U };
    (void)display_write(disp, x, y, &desc, glyphbuf);
}

static void draw_text(const struct device *disp, uint16_t x, uint16_t y,
                      const char *s, uint16_t fg_be, uint16_t bg_be) {
    uint16_t cx = x, cy = y;
    while (*s) {
        if (*s == '\n') { cx = x; cy = (uint16_t)(cy + CH + SCALE); }
        else { draw_char(disp, cx, cy, *s, fg_be, bg_be); cx = (uint16_t)(cx + CW); }
        s++;
    }
}

void main(void)
{
    const struct device *gpio0 = DEVICE_DT_GET(BLK_PORT);
    if (device_is_ready(gpio0)) {
        gpio_pin_configure(gpio0, BLK_PIN, GPIO_OUTPUT_ACTIVE);
    }

    const struct device *disp = DEVICE_DT_GET(DT_CHOSEN(zephyr_display));
    if (!device_is_ready(disp)) { LOG_ERR("display not ready"); return; }

    (void)display_set_pixel_format(disp, PIXEL_FORMAT_RGB_565);
    (void)display_blanking_off(disp);

    struct display_capabilities cap;
    display_get_capabilities(disp, &cap);
    uint16_t W = cap.x_resolution, H = cap.y_resolution;
    LOG_INF("Display %ux%u", W, H);

    uint16_t white = rgb565_be(255,255,255);
    uint16_t black = rgb565_be(0,0,0);

    fill_screen(disp, W, H, white);
    draw_text(disp, 8, 8, "Zephyr 5x7 font demo", black, white);
    draw_text(disp, 8, 8 + CH + SCALE, "Hello, world! 1234", black, white);

    for (int sec = 0; ; ++sec) {
        char buf[32];
        snprintk(buf, sizeof(buf), "sec=%d   ", sec);
        draw_text(disp, 8, (uint16_t)(8 + 2*(CH + SCALE)), buf, black, white);
        k_msleep(1000);
    }
}
